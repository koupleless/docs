---
title: 1.3.1 Architecture Principles
date: 2024-01-25T10:28:32+08:00
description: Koupleless Architecture Principles
weight: 100
---

## Modular Application Architecture
To address these issues, we have performed both horizontal and vertical splits on applications. Firstly, the vertical split involves dividing the application into **base** and **business** layers, corresponding to two layers of organizational responsibilities. The base team, like traditional applications, is responsible for machine maintenance, common logic abstraction, business architecture governance, and providing runtime resources and environments for business. By separating concerns, all underlying infrastructure below the business layer is shielded, allowing the focus to remain on the business itself. Secondly, we horizontally partition the business into multiple modules, allowing independent parallel iteration among them without interference. Since modules exclude the base part, their build artifacts are lightweight, and their startup logic only encompasses the business itself, enabling rapid startup and providing sub-second verification capabilities, thus optimizing module development efficiency to the utmost extent.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695131313965-18385213-eded-4a6b-b554-db5312fa2c9d.png#clientId=ua84a92a5-30aa-4&from=paste&height=431&id=udb6b29d5&originHeight=862&originWidth=3448&originalType=binary&ratio=2&rotation=0&showTitle=false&size=192627&status=done&style=none&taskId=u9a114a24-0887-48d9-87b2-57d3e15eb80&title=&width=1724)<br />Before the split, each developer may have perceived all the code and logic from the framework to middleware to business common parts to business itself. After the split, the collaboration within the team has changed, and developers are divided into two roles: base and module developers. Module developers are not concerned with resources and capacity but enjoy the ability to deploy and verify changes in seconds, focusing solely on business logic.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695131554610-ef5c4a2f-0080-45eb-8fed-55fdf5d827f9.png#clientId=ua84a92a5-30aa-4&from=paste&height=459&id=u7227f759&originHeight=918&originWidth=3714&originalType=binary&ratio=2&rotation=0&showTitle=false&size=309179&status=done&style=none&taskId=u12307968-2a79-4f77-9c78-e976399c60e&title=&width=1857)

Here it's crucial to understand how we perform these vertical and horizontal splits. The split is for isolation, and isolation is for independent iteration, stripping unnecessary dependencies. However, isolation alone, without sharing, is akin to merely relocating deployment positions, which may not yield desirable results. Thus, besides isolation, we also emphasize sharing capabilities. Therefore, it's essential to focus on understanding the principles behind modular architecture in terms of isolation and sharing.

### Module Definition
Before delving further, let's clarify what modules are in this context. Modules are derived by subtracting the base part from the original application. This subtraction is achieved by setting the scope of dependencies in the module as provided.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132446404-0571be28-5cdf-452e-90f5-001a4209c750.png#clientId=u177778f7-e9cd-4&from=paste&height=142&id=ud796498d&originHeight=516&originWidth=1834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=108247&status=done&style=none&taskId=u8201db6e-cf5e-4fbd-ab24-6a0223e1709&title=&width=506)<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132481921-6fb1c3da-0de3-46ce-bf8e-cc645f63157c.png#clientId=u177778f7-e9cd-4&from=paste&height=187&id=u31cba15e&originHeight=524&originWidth=1026&originalType=binary&ratio=2&rotation=0&showTitle=false&size=205261&status=done&style=none&taskId=u2c981d7a-dfff-43c6-b6c6-5c6a5701d2b&title=&width=367)<br />A module can be defined by these three points:

1. A jar package generated by SpringBoot packaging
2. A module: a SpringContext + a ClassLoader
3. Hot deployment (no need to restart the process during upgrade)

### Isolation and Sharing of Modules
Modules are isolated in terms of configuration and code through ClassLoader and SpringContext. They share configurations and code classes between modules and bases through SOFAArk and between multiple modules through SpringContext Manager.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695132610081-3efe470f-5c65-4d46-b4e4-1ecb15c8d789.png#clientId=u771aab18-101c-4&from=paste&height=313&id=u4c63a679&originHeight=972&originWidth=1334&originalType=binary&ratio=2&rotation=0&showTitle=false&size=160772&status=done&style=none&taskId=uafe9a1eb-025c-4e1e-9316-35b8bd32b96&title=&width=429)<br />Within the JVM, this is achieved through:

1. Ark Container providing a multi-ClassLoader runtime environment
2. Arklet managing module lifecycles
3. Framework Adapter associating SpringBoot lifecycle with module lifecycle
4. SOFAArk's default delegation loading mechanism bridging module and base class delegation loading
5. SpringContext Manager providing bean and service discovery mechanisms
6. Bases essentially being modules with independent SpringContext and ClassLoader

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695139080634-1669ea76-c486-47fc-ac4f-5900833896b9.png#clientId=u71a0730f-fb54-4&from=paste&height=275&id=u1cf30803&originHeight=722&originWidth=1428&originalType=binary&ratio=2&rotation=0&showTitle=false&size=198221&status=done&style=none&taskId=u88cd7c27-4850-4b02-9c6f-504b4456a94&title=&width=544)

However, modularization technologies in the Java domain have developed for 20 years. Why can modularization technologies be scaled within Ant Group? The core reason lies in the multi-module capabilities based on SOFAArk and SpringContext Manager, which provide a low-cost usage approach.

#### Isolation Aspect
Compared to other modularization technologies, from an isolation perspective, JPMS and Spring Modulith impose limitations through custom rules, with Spring Modulith requiring verification in unit tests. The isolation capabilities are relatively weak and somewhat tricky, with significant retrofitting costs for legacy applications, and even infeasible for legacy applications. Similar to OSGi, SOFAArk employs ClassLoader and SpringContext for configuration and code, as well as bean and service isolation, maintaining consistency with the native application startup mode.

#### Sharing Aspect
While SOFAArk shares isolation mechanisms with OSGi, OSGi, JPMS, and Spring Modulith all require defining import/export lists or other configurations between source and target modules, resulting in high usage costs for business modules that need to understand and perceive multi-module technologies. SOFAArk defines a default class delegation loading mechanism and cross-module bean and service discovery mechanisms, enabling business usage of multi-module capabilities without modification.<br />Additionally, why can the modularization technology based on SOFAArk provide these default capabilities at low cost and emphasize low-cost usage? The main reason is that we have differentiated roles for modules, distinguishing between bases and modules. Based on this core reason, we have also attached importance to low-cost usage and made important design considerations and trade-offs. For specific design considerations and trade-offs, refer to the technical implementation article.

### Inter-Module Communication
Inter-module communication relies primarily on the bean and service discovery mechanism provided by SpringContext Manager.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695171905613-2546f555-ff25-4a58-81aa-02d77bfb2b1d.png#clientId=ud7a2066a-ba29-4&from=paste&height=307&id=uc8826222&originHeight=724&originWidth=1048&originalType=binary&ratio=2&rotation=0&showTitle=false&size=202275&status=done&style=none&taskId=u537670c5-c728-487a-9710-80986ce8532&title=&width=444)

#### Module Evolution
Looking back at the mentioned major issues, it can be seen that through the isolation and sharing capabilities of modular architecture, problems such as complex infrastructure, collaboration blocking, and high resources and long-term maintenance costs can be solved. However, the issue of inconsistent agility between microservices splitting and business remains unresolved.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695175219841-965cd163-a4bd-4cd0-b828-c620b29c0ffc.png#clientId=uaaa65411-0843-4&from=paste&height=185&id=ua68375b7&originHeight=894&originWidth=2906&originalType=binary&ratio=2&rotation=0&showTitle=false&size=417377&status=done&style=none&taskId=ud94c9602-7cd1-4bcb-8654-39fe8938d37&title=&width=602)<br />Here, we address this by reducing the cost of microservices splitting. So how do we reduce the cost of microservices splitting? The main approach is to introduce modular architecture between monolithic and microservices architectures.

1. Modules do not occupy resources, so splitting incurs no resource costs.
2. Modules do not include business common parts, frameworks, or middleware parts, so modules incur no long-term SDK upgrade and maintenance costs.
3. Modules themselves are SpringBoot, and we provide tools to assist in the low-cost splitting of monolithic applications into modular applications.
4. Modules have flexible deployment capabilities; they can be deployed together in one JVM or separately, allowing modules to evolve into microservices or revert to monolithic application modes at low cost.

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695175141130-d3b55e17-70c3-4e7c-aeef-2e071f89ada8.png#clientId=uaaa65411-0843-4&from=paste&height=316&id=u589ef06e&originHeight=632&originWidth=3642&originalType=binary&ratio=2&rotation=0&showTitle=false&size=139102&status=done&style=none&taskId=uf9f96d68-7456-4af5-951e-d9351092988&title=&width=1821)<br />The arrows in the diagram are bidirectional. If there are too many microservices currently split, multiple microservices can also be cost-effectively transformed into modules and deployed together in one JVM. So, the essence here is to add a bidirectional transitional modular architecture between monolithic and microservices architectures, reducing the cost of transformation while allowing developers to evolve or roll back according to business needs. This can solve several problems of microservices.

### Advantages of Modular Architecture
The main advantages of modular architecture are concentrated in these four points: speed, savings, flexible deployment, and evolvability, <br />![image.png](https://github.com/sofastack/sofa-serverless/assets/3754074/11d1d662-d33b-482b-946b-bf600aeb34da)


When compared to traditional applications, the data below show more than a 10x improvement in development, deployment, and runtime stages.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695180250909-f5eca1b3-c416-4bac-9732-549a9bed8b87.png#clientId=ueb39d37f-ca7b-4&from=paste&height=261&id=u8907b613&originHeight=522&originWidth=2838&originalType=binary&ratio=2&rotation=0&showTitle=false&size=219589&status=done&style=none&taskId=ua4b2bd1b-a75f-4945-abce-68826a43377&title=&width=1419)

## Platform Architecture
Just having application architecture is not enough. It is necessary to provide complete supporting capabilities from the development stage to the operation and runtime stages to truly realize the advantages of modular application architecture to developers.<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/149473/1695182073971-12b14861-b6fa-470c-a140-737d40ff0b3e.png#clientId=u9014394b-3a6a-4&from=paste&height=192&id=ub53430b2&originHeight=384&originWidth=1720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79335&status=done&style=none&taskId=u1eb2a897-c2ca-437f-8d56-7067be175e2&title=&width=860)<br />During the development stage, it is necessary to provide capabilities for base access, module creation, and more importantly, local rapid build and debugging capabilities for modules; during the operation stage, provide fast module deployment capabilities, and on top of module deployment, provide A/B testing and second-level scaling capabilities; during the runtime stage, provide reliability capabilities for modules, fine-grained control of observability, traffic, scheduling, and scaling.

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2025/png/144256539/1748936679737-4f09f2ab-88ea-477a-b148-753ed30fbb42.png?x-oss-process=image%2Fformat%2Cwebp)<br />Component View

Within the entire platform, four components are needed:

1. Development Toolchain: including application splitting, application merging, module slimming, module building, code scanning and other capabilities, helping developers quickly build base and module applications.
2. Development Tool Arkctl: providing module creation, rapid debugging testing, and other capabilities.
3. Runtime Components SOFAArk, Arklet: providing module operation, module lifecycle management, and multi-module runtime environment, currently supporting 36 common frameworks in the Java ecosystem.
4. Control Plane Components ModuleController: providing base discovery, module deployment, module state synchronization and other capabilities, implementing state mapping between base/module and K8S Node/Pod based on Virtual-Kubelet.

<br/>
